# 1. 디스크 읽기방식을 고려하자

랜덤 I/O와 순차I/O
디스크 헤더를 많이 음직이는 랜덤 I/O는 비용이 큰 순차I/O보다 비용이 크다. SSD를 사용하면 랜덤 I/O의 비용을 줄일 수 있지만, 그래도 순차 I/O에 비해서는 성능이 떨어진다.

데이터베이스의 대부분의 작업은 작은 데이터를 빈번히 읽고 쓰는 작업이 대부분이기 때문에 랜덤 I/O가 일어나는데 쿼리 튜닝이란 이러한 랜덤 I/O 자체를 줄여주는것에 목적이 있다고 볼수 있다.(꼭 필요한 데이터만 읽도록 하는것!)
<br>
<br>

# 2. 인덱스란?
DBMS의 인덱스도 SortedList와 같이 항상 정렬된 상태를 유지한다.

즉 항상 정렬된 상태를 유지하기 위해 데이터가 저장될 때마다 항상 값을 정렬해야한다. 그렇기 때문에 인덱스란 데이터의 저장 성능을 희생하고 읽기 속도를 높이는 기능이다. 즉 인덱스를 설정할때는 저장 성능을 어느정도까지 희생할 지를 고려해야한다.

<br>
<br>

# 3. 인덱스의 구분

## 역할별 구분

프라이머리키
- 그 레코드를 대표하는 값으로 NULL과 중복을 허용하지 않는다.

보조키(세컨더리 키)
- 프라이머리 키를 제외한 모든 인덱스, 유니크 인덱스의 경우 프라이머리 키와 성격이 비슷해서 대체키라고도 불림
<br>
<br>
## 알고리즘 별 구분

B-Tree 인덱스:
- 가장 일반적으로 사용되는 인덱스 컬럼 값을 그대로 가지고 인덱싱 한다.

Hash 인덱스:
- 컬럼값을 해시값으로 변경해 인덱싱한다. 매우빠른 검색속도,
- 주로 메모리 기반 DB에서 사용 컬럼값 전체를 
- 해시값으로 변경 하기 때문에 컬럼값의 일부만 가지고 검색을 할 수 없다.
<br>
<br>
## 데이터의 중복 여부로 구분
유니크 인덱스:
- 같은 값이 오직 1개만 존재 ⇒ 이는 옵티마이저 입장에서 매우 중요한 문제 (유니크한 컬럼에서 동등조건 비교(=)로 검색이 들어가면 1개만 찾고 더이상 검색을 수행하지 않아도 되기 때문)

논유니크 인덱스